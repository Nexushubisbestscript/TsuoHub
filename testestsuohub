local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer

local Fluent = loadstring(game:HttpGet("https://github.com/dawid-scripts/Fluent/releases/latest/download/main.lua"))()
local SaveManager = loadstring(game:HttpGet(
    "https://raw.githubusercontent.com/dawid-scripts/Fluent/master/Addons/SaveManager.lua"))()
local InterfaceManager = loadstring(game:HttpGet(
    "https://raw.githubusercontent.com/dawid-scripts/Fluent/master/Addons/InterfaceManager.lua"))()
local GuiService = game:GetService("GuiService")

local screenResolution = GuiService:GetScreenResolution()
local screenWidth = screenResolution.X
local screenHeight = screenResolution.Y

local windowWidth = screenWidth * 0.6
local windowHeight = screenHeight * 0.6

-- UDim2.fromOffset(580, 460),

local Window = Fluent:CreateWindow({
    Title = "TsuoHub Blade Ball",
    SubTitle = "by mani / discord.gg/tsuoscripts",
    TabWidth = 160,
    Size = UDim2.new(0, windowWidth, 0, windowHeight),
    Acrylic = true, -- The blur may be detectable, setting this to false disables blur entirely
    Theme = "Dark",
    MinimizeKey = Enum.KeyCode.LeftControl -- Used when theres no MinimizeKeybind
})

-- Fluent provides Lucide Icons https://lucide.dev/icons/ for the tabs, icons are optional
local Tabs = {
    Credits = Window:AddTab({
        Title = "Credits",
         Icon = "moon"
    }),
    Combat = Window:AddTab({
        Title = "Combat",
        Icon = "swords"
    }),
    SettingsScript = Window:AddTab({
        Title = "Settings",
        Icon = "settings"
    }),
        OpenBox = Window:AddTab({
        Title = "OpenBox",
        Icon = "package"
    }),
        FPS = Window:AddTab({
        Title = "FpsBooster",
        Icon = "cross"
    }),
    Mobile = Window:AddTab({
        Title = "Mobile Support",
        Icon = "smartphone"
    }),
    SettingsInterface = Window:AddTab({
        Title = "Interface",
        Icon = "paintbrush"
    }),
}



 Tabs.Credits:AddButton({
    Title = "By Mani",
    Description = "dc: maniunico",
    Callback = function()
        Window:Dialog({
             Title = "X",
            Content = "TsuoScripts Blade Ball",
             Buttons = {
                {
                     Title = "Y",
                    Callback = function()
                        print("Y")
                     end
                 },
                {
                    Title = "z",
                     Callback = function()
                        print("z")
                    end
                }
            }
        })
    end
})

local Options = Fluent.Options

-- Variables
local workspace = game:GetService("Workspace")
local LocalPlayer = game:GetService("Players").LocalPlayer
local Balls = game:GetService("Workspace").Balls

local IsTargeted = false
local readyToDeflect = false

local UserInputService = game:GetService("UserInputService")
local replicatedStorage = game:GetService("ReplicatedStorage")

local heartbeatConnection
local heartbeatConnectionAutoSpamParry

local spamParry = false

local adjustment = 3.5
local hit_range = 0.2

local SPAM_PARRY_DISTANCE_THRESHOLD = 25
local SPAM_PARRY_BALL_DISTANCE_THRESHOLD = 35

local ShowFpsAndPing = false

local function ShowFpsAndPing()
    loadstring(game:HttpGet('https://raw.githubusercontent.com/1201for/littlegui/main/FPS-Counter'))()
end


-- Functions
function FindBall()
    for _, ball in pairs(Balls:GetChildren()) do
        if ball:GetAttribute("realBall") then
            return ball
        end
    end
end

function IsTarget()
    local ball = FindBall()
    return ball and ball:GetAttribute("target") == LocalPlayer.Name
end

function GetTarget()
    local ball = FindBall()
    if ball then
        local playerTarget = game.Players:FindFirstChild(ball:GetAttribute("target"))
        return playerTarget
    end
end

function CheckPlayerIsAlive(player)
    return game.Workspace.Alive:FindFirstChild(player.Name) ~= nil
end

function DetectBall()
    local ball = FindBall()

    if ball and LocalPlayer.Character then
        local ballVelocity = ball.Velocity.Magnitude
        local ballPosition = ball.Position
        local humanoidRootPart = LocalPlayer.Character:FindFirstChild("HumanoidRootPart")

        if humanoidRootPart then
            local playerPosition = humanoidRootPart.Position
            local distance = (ballPosition - playerPosition).Magnitude

            -- Descomente estas linhas caso deseje ajustar a dist√¢ncia com ping e outros fatores
            local pingAccountability = ballVelocity * (game.Stats.Network.ServerStatsItem["Data Ping"]:GetValue() / 1000)
            distance = distance - pingAccountability
            distance = distance - adjustment

            return distance / ballVelocity <= hit_range
        end
    end

    return false
end

function AutoParry()
    local isTargeted = IsTarget()

    if not isTargeted then
        readyToDeflect = true
    end
    
    local character = LocalPlayer.Character
    local humanoidRootPart = character and character:FindFirstChild("HumanoidRootPart")

    if isTargeted and readyToDeflect and DetectBall() then
        if Options.AutoCurveBall.Value then
            local args = {
                [1] = 0.5,
                [2] = CFrame.new(-271.4189758300781, 113.82926940917969, -97.50477600097656, -0.9636251926422119, -0.2631970942020416, -0.04640869423747063, 3.725290298461914e-09, 0.17364796996116638, -0.9848077893257141, 0.26725733280181885, -0.9489855766296387, -0.16733156144618988),
                [3] = {
                    ["5079211368"] = Vector3.new(569.6488647460938, 522.0974731445312, 3.2013320922851562),
                    ["1767223384"] = Vector3.new(2012.630859375, 3809.23046875, 18.150421142578125)
                },
                [4] = {
                    [1] = 960,
                    [2] = 464
                }
            }
            game.ReplicatedStorage.Remotes.ParryAttempt:FireServer(unpack(args))
        else
            replicatedStorage.Remotes.ParryButtonPress:Fire()
        end
        
        readyToDeflect = false
    end
end

local function startAutoParry()
    heartbeatConnection = game:GetService("RunService").Heartbeat:Connect(AutoParry)
end

local function stopAutoParry()
    if heartbeatConnection then
        heartbeatConnection:Disconnect()
        heartbeatConnection = nil
    end
end




local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")
local ParryAttempt = ReplicatedStorage.Remotes.ParryAttempt

local function SpamParry()
    while spamParry do
        local targetPosition = Vector3.new(-273.400146484375, -724.8031005859375, -20.92414093017578)
        local parryCFrame = CFrame.new(-254.2939910888672, 112.13581848144531, -119.27256774902344) *
                            CFrame.Angles(-2.029526710510254, 0.5662040710449219, 2.314905881881714)

        ParryAttempt:FireServer(1.5, parryCFrame, {["2617721424"] = targetPosition}, {910, 154})

        RunService.Heartbeat:Wait()
    end
end


local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

local function FindClosestPlayer()
    local Character = LocalPlayer.Character
    if not Character or not Character:FindFirstChild("HumanoidRootPart") then
        return nil
    end

    local PlayerPosition = Character.HumanoidRootPart.Position
    local closestPlayer = nil
    local closestDistance = math.huge
    
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
            local distance = (player.Character.HumanoidRootPart.Position - PlayerPosition).Magnitude
            if distance < closestDistance then
                closestPlayer = player
                closestDistance = distance
            end
        end
    end

    return closestPlayer, closestDistance, PlayerPosition
end

local function startAutoSpamParry()
    local heartbeatConnectionAutoSpamParry
    heartbeatConnectionAutoSpamParry = RunService.Heartbeat:Connect(function()
        local Ball = FindBall()

        if not Ball then
            spamParry = false
            return
        end

        local closestPlayer, closestDistance, PlayerPosition = FindClosestPlayer()
        local BallVelocity = Ball.Velocity.Magnitude
        local BallPosition = Ball.Position

        if not PlayerPosition then
            spamParry = false
            return
        end

        local DistanceBall = (BallPosition - PlayerPosition).Magnitude

        if closestPlayer and closestDistance < SPAM_PARRY_DISTANCE_THRESHOLD and DistanceBall <
            SPAM_PARRY_BALL_DISTANCE_THRESHOLD and not spamParry then
            if Ball:GetAttribute("target") == LocalPlayer.Name then
                print("enable spam parry")
                spamParry = true
                SpamParry()
            end
        elseif (closestDistance > SPAM_PARRY_DISTANCE_THRESHOLD or DistanceBall > SPAM_PARRY_BALL_DISTANCE_THRESHOLD) and
            spamParry then
            print(closestPlayer, closestDistance, DistanceBall)
            print("disable spam parry")
            spamParry = false
        end
    
    end)

    return heartbeatConnectionAutoSpamParry
end

local function stopAutoSpamParry(heartbeatConnection)
    spamParry = false
    if heartbeatConnection then
        heartbeatConnection:Disconnect()
    end
end


local function FpsBooster()
    loadstring(game:HttpGet("https://raw.githubusercontent.com/confusedcx/g/main/g"))()
end

do
    local ToggleParry = Tabs.Combat:AddToggle("AutoParry", {
        Title = "Auto Parry",
        Default = false
    })
    ToggleParry:OnChanged(function()
        if Options.AutoParry.Value then
            startAutoParry()
        else
            stopAutoParry()
        end
    end)
    -- Options.MyToggle:SetValue(false)

    local KeybindSpamParry = Tabs.Combat:AddKeybind("KeybindSpamParry", {
        Title = "Spam Parry",
        Mode = "Toggle", -- Always, Toggle, Hold
        -- Default toogle E
        Default = "E", -- String as the name of the keybind (MB1, MB2 for mouse buttons)
        -- Occurs when the keybind is clicked, Value is `true`/`false`
        Callback = function(Value)
            spamParry = not spamParry
            coroutine.wrap(SpamParry)()
        end
    })

    local ToggleAutoSpamParry = Tabs.Combat:AddToggle("AutoSpamParry", {
        Title = "Auto Spam Parry",
        Default = false
    })
    ToggleAutoSpamParry:OnChanged(function()
        if Options.AutoSpamParry.Value then
            startAutoSpamParry()
        else
            stopAutoSpamParry()
        end
    end)

    local ToggleAutoCurveBall = Tabs.Combat:AddToggle("AutoCurveBall", {
        Title = "Auto Curve Ball",
        Default = false
    })
    -- ToggleAutoCurveBall:OnChanged(function()
    --     if Options.AutoSpamParry.Value then
    --         startAutoSpamParry()
    --     else
    --         stopAutoSpamParry()
    --     end
    -- end)

    Tabs.OpenBox:AddButton({
        Title = "Open sword box",
        Description = "",
        Callback = function()
            local _, sword = game:GetService("ReplicatedStorage").Remotes.Store.RequestOpenSwordBox:InvokeServer()
            if not _ then
                sword = "You do not have enough money"
            end
            Fluent:Notify({
                Title = "Open sword box",
                Content = sword,
                Duration = 8
            })
        end
    })
    Tabs.OpenBox:AddButton({
        Title = "Open explosion box",
        Description = "",
        Callback = function()
            local _, explosion = game:GetService("ReplicatedStorage").Remotes.Store.RequestOpenExplosionBox:InvokeServer()
            if not _ then
                explosion = "You do not have enough money"
            end
            Fluent:Notify({
                Title = "Open explosion box",
                Content = explosion,
                Duration = 8
            })
        end
    })


    local SliderSpeed = Tabs.SettingsScript:AddSlider("SliderSpeed", {
        Title = "Speed",
        -- Description = "",
        Default = 3.5,
        Min = 3,
        Max = 4,
        Rounding = 1,
        Callback = function(Value)
            print(Value)
            adjustment = Value
        end
    })

    local SliderHitRange = Tabs.SettingsScript:AddSlider("SliderHitRange", {
        Title = "Hit Range",
        -- Description = "",
        Default = 0.2,
        Min = 0,
        Max = 3,
        Rounding = 1,
        Callback = function(Value)
            print(Value)
            hit_range = Value
        end
    })

    Tabs.FPS:AddButton({
        Title = "Remove parry light effect",
        Description = "",
        Callback = function()
            while game:GetService("RunService").Heartbeat:wait() do
                local workspaceItems = game.Workspace:GetChildren()
                for i = 1, #workspaceItems do
                    local item = workspaceItems[i]
                    if item.Name == "clash" then
                        item:Destroy()
                    end
                end
            end
        end
    })

    Tabs.FPS:AddButton({
        Title = "FPS Boost",
        Description = "",
        Callback = function()
            FpsBooster()
        end
    })

    Tabs.Mobile:AddButton({
        Title = "Mobile Keyboard",
        Description = "",
        Callback = function()
            loadstring(game:HttpGet(
                "https://gist.githubusercontent.com/RedZenXYZ/4d80bfd70ee27000660e4bfa7509c667/raw/da903c570249ab3c0c1a74f3467260972c3d87e6/KeyBoard%20From%20Ohio%20Fr%20Fr"))()
        end
    })

    Tabs.FPS:AddButton({
        Title = "Show Fps And Ping",
        Description = "",
        Callback = function()
            loadstring(game:HttpGet(
                "https://raw.githubusercontent.com/1201for/littlegui/main/FPS-Counter"))()
        end
    })

end

-- Addons:
-- SaveManager (Allows you to have a configuration system)
-- InterfaceManager (Allows you to have a interface managment system)

-- Hand the library over to our managers
SaveManager:SetLibrary(Fluent)
InterfaceManager:SetLibrary(Fluent)

-- Ignore keys that are used by ThemeManager.
-- (we dont want configs to save themes, do we?)
SaveManager:IgnoreThemeSettings()

-- You can add indexes of elements the save manager should ignore
SaveManager:SetIgnoreIndexes({})

-- use case for doing it this way:
-- a script hub could have themes in a global folder
-- and game configs in a separate folder per game
InterfaceManager:SetFolder("FluentScriptHub")
SaveManager:SetFolder("FluentScriptHub/specific-game")

InterfaceManager:BuildInterfaceSection(Tabs.SettingsInterface)
SaveManager:BuildConfigSection(Tabs.SettingsInterface)

Window:SelectTab(1)

Fluent:Notify({
    Title = "Fluent",
    Content = "The script has been loaded.",
    Duration = 8
})

-- You can use the SaveManager:LoadAutoloadConfig() to load a config
-- which has been marked to be one that auto loads!
SaveManager:LoadAutoloadConfig()

